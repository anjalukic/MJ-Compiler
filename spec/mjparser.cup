

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, SEMI, CONST, LBRACKET, RBRACKET, LPAREN, RPAREN, EQUAL, RETURN, PLUS, MINUS, COMMA, PRINT, VOID;
terminal Integer NUMCONST;
terminal Character CHARCONST;
terminal String BOOLCONST;
terminal String IDENT;
terminal IF, ELSE, ASSIGN, BREAK, CONTINUE, READ, INCR, DECR, OR, AND, NEW, DIFF, GT, LT, GTE, LTE, MUL, DIV, MOD, DOT, FOR;

nonterminal Program, DeclList, Decl, VarDeclList, VarDecl, ConstDeclList, ConstDecl, VarMulDeclList, Type, MethodDeclList, MethodDecl;
nonterminal FormPars, StatementList, FormalParamList, FormalParamDecl, Statement;
nonterminal Designator, Expr, Term, Addop, Factor, ActualPars, ActualParamList, Relop;
nonterminal DesignatorStatement, Condition, CondTerm, CondFact, Mulop, NegTerm, DesignatorStmtOptional, ConditionOptional;

precedence left ELSE;

Program ::= (Program) PROG IDENT DeclList LBRACE MethodDeclList RBRACE;

DeclList ::= (AllDeclarationsList) DeclList Decl
			|
			(NoDecl) /* epsilon */
			;

Decl ::= (OneVarDeclListEnded) Type VarDeclList SEMI
		| 
		(OneConstDeclListEnded) CONST Type ConstDeclList SEMI
		;

VarDeclList ::= (OneVarDeclList) VarDeclList COMMA VarDecl
				|
				(OneSingleVarDecl) VarDecl
				;
		
VarDecl ::= (VarDeclSingle) IDENT
			|
			(VarDeclBrackets) IDENT LBRACKET RBRACKET
			|
		    (ErrorVarDecl) error:l
		   {: parser.report_error("Izvrsen oporavak do ; ili , u liniji " + lleft, null);  :}
			;

ConstDeclList ::= (OneConstDeclList) ConstDeclList COMMA ConstDecl
				|
				(OneSingleConstDecl) ConstDecl
				;

ConstDecl ::= (ConstDeclNumber) IDENT ASSIGN NUMCONST
			|
			(ConstDeclBool) IDENT ASSIGN BOOLCONST
			|
			(ConstDeclChar) IDENT ASSIGN CHARCONST
			;
			
VarMulDeclList ::= (VarMultiDeclList) VarMulDeclList Type VarDeclList SEMI
					|
					(NoVarDecls) /*epsilon*/
					;

Type ::= (Type) IDENT:typeName;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDecl) /* epsilon */
				;
				
MethodDecl ::= (TypeMethodDecl) Type:retType IDENT:methName LPAREN FormPars RPAREN VarMulDeclList LBRACE StatementList RBRACE
			|
			(VoidMethodDecl) VOID IDENT:methName LPAREN FormPars RPAREN VarMulDeclList LBRACE StatementList RBRACE
			;

FormPars ::= (FormParams) FormalParamList
		  |
		  (NoFormParam) /* epsilon */
		  ;
		  
FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
				|
				(SingleFormalParamDecl) FormalParamDecl
				;
				
FormalParamDecl ::= (FormalParamDeclNoBrackets) Type IDENT
				|
				(FormalParamDeclBrackets) Type IDENT LBRACKET RBRACKET
				|
				(ErrorFormalPars) error:l
		   		{: parser.report_error("Izvrsen oporavak do , ili ) u liniji " + lleft, null);  :}
				;

StatementList ::= (Statements) StatementList Statement
				|
				(NoStmt) /* epsilon */
				;
/*Statement ::= (MatchedStmt) Matched
		   |
		   (UnmatchedStmt) Unmatched
		   ; 

Unmatched ::= (UnmatchedIf) IF LPAREN Condition RPAREN Statement
		 	|
		 	(UnmatchedIfElse) IF LPAREN Condition RPAREN Matched ELSE Unmatched
		 	|
		 	(ForStatement1) FOR LPAREN DesignatorStmtOptional SEMI ConditionOptional SEMI DesignatorStmtOptional RPAREN Unmatched
		 	;
		 

Matched ::= (DesignatorStmt) DesignatorStatement SEMI
			|
		   (MatchedStatement) IF LPAREN Condition RPAREN Matched ELSE Matched
		   	|
		   	(ForStatement) FOR LPAREN DesignatorStmtOptional SEMI ConditionOptional SEMI DesignatorStmtOptional RPAREN Matched
		   	|
		   	(BreakStatement) BREAK SEMI
		   	|
		   	(ContinueStatement) CONTINUE SEMI
			|
		   (ReturnExpr) RETURN Expr:t SEMI
			|
		   (ReturnNoExpr) RETURN SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
		   (PrintStmt) PRINT LPAREN Expr RPAREN SEMI
		   |
		   (PrintStmtArg) PRINT LPAREN Expr COMMA NUMCONST RPAREN SEMI
		   |
		   (BlockOfStmts) LBRACE StatementList RBRACE
		   |
		    (ErrorStmt) error SEMI:l
		   {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}
		   ;
		   */			
Statement ::= (DesignatorStmt) DesignatorStatement SEMI
			|
		   (MatchedStatement) IF LPAREN Condition RPAREN Statement ELSE Statement
		   	|
		   	(UnmatchedStatement) IF LPAREN Condition RPAREN Statement
		   	|
		   	(ForStatement) FOR LPAREN DesignatorStmtOptional SEMI ConditionOptional SEMI DesignatorStmtOptional RPAREN Statement
		   	|
		   	(BreakStatement) BREAK SEMI
		   	|
		   	(ContinueStatement) CONTINUE SEMI
			|
		   (ReturnExpr) RETURN Expr:t SEMI
			|
		   (ReturnNoExpr) RETURN SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
		   (PrintStmt) PRINT LPAREN Expr RPAREN SEMI
		   |
		   (PrintStmtArg) PRINT LPAREN Expr COMMA NUMCONST RPAREN SEMI
		   |
		   (BlockOfStmts) LBRACE StatementList RBRACE
		   |
		    (ErrorStmt) error SEMI:l
		   {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}
		   ;
		   
DesignatorStatement ::= (Assignment) Designator ASSIGN Expr
					|
					(FunctionCall) Designator LPAREN ActualPars RPAREN
					|
					(Increment) Designator INCR
					|
					(Decrement) Designator DECR
					;
					
DesignatorStmtOptional ::= (OneDesignatorStmt) DesignatorStatement
							| (NoDesignatorStmt) /*epsilon*/
							;
					
ActualPars ::= (Actuals) ActualParamList
			|
			(NoActuals) /* epsilon */
			;
		
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
				|
				(ActualParam) Expr
				;
				
Condition ::= (MultipleConditionsOR) Condition OR CondTerm
			|
			(SingleCondition) CondTerm
			;
			
ConditionOptional ::= (OptionalCondition) Condition
							| (NoCondition) /*epsilon*/
							| (ErrorCondition) error:l
							{: parser.report_error("Izvrsen oporavak u for-u do ; u liniji " + lleft, null);  :}
							;
	
			
CondTerm ::=  (MultipleConditionsAND) CondTerm AND CondFact
			|
			(SingleCondTerm) CondFact
			;
			
CondFact ::= (SingleCondFact) Expr
			|
			(RelCondFact) Expr Relop Expr
			;

NegTerm ::= (NegTerm) MINUS Term;

Expr ::= (AddExpr) Expr Addop Term
		|
		(SingleExpr) Term
		|
		(SingleNegExpr) NegTerm
		;

Term ::= (MulTerm) Term Mulop Factor
			|
			(SingleTerm) Factor;

Factor ::= (Var) Designator:d
		| 
		(FuncCall) Designator:func LPAREN ActualPars RPAREN
		|
		(NumConst) NUMCONST
		|
		(CharConst) CHARCONST
		|
		(BoolConst) BOOLCONST
		|
		(NewType) NEW Type
		|
		(NewArray) NEW Type LBRACKET Expr RBRACKET
		|
		(NestedExpr) LPAREN Expr RPAREN
		;
					
Designator ::= (SimpleDesignator) IDENT
			|
			(DesignatorArray) IDENT LBRACKET Expr RBRACKET
			;

Relop ::= (EqualOp) EQUAL
		| (DifferentOp) DIFF
		| (GreaterOp) GT
		| (GreaterEqualOp) GTE
		| (LessOp) LT
		| (LessEqualOp) LTE
		;

Addop ::= (Addop) PLUS
		| (MinusOp) MINUS
		;
		
Mulop ::= (Mulop) MUL
		| (DivOp) DIV
		| (ModOp) MOD
		;
		
		

